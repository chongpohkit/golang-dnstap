// Code generated by protoc-gen-go. DO NOT EDIT.
// source: dnstap.proto

package dnstap

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// SocketFamily: the network protocol family of a socket. This specifies how
// to interpret "network address" fields.
type SocketFamily int32

const (
	SocketFamily_INET  SocketFamily = 1
	SocketFamily_INET6 SocketFamily = 2
)

var SocketFamily_name = map[int32]string{
	1: "INET",
	2: "INET6",
}

var SocketFamily_value = map[string]int32{
	"INET":  1,
	"INET6": 2,
}

func (x SocketFamily) Enum() *SocketFamily {
	p := new(SocketFamily)
	*p = x
	return p
}

func (x SocketFamily) String() string {
	return proto.EnumName(SocketFamily_name, int32(x))
}

func (x *SocketFamily) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SocketFamily_value, data, "SocketFamily")
	if err != nil {
		return err
	}
	*x = SocketFamily(value)
	return nil
}

func (SocketFamily) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0f06582ff84ec462, []int{0}
}

// SocketProtocol: the transport protocol of a socket. This specifies how to
// interpret "transport port" fields.
type SocketProtocol int32

const (
	SocketProtocol_UDP SocketProtocol = 1
	SocketProtocol_TCP SocketProtocol = 2
)

var SocketProtocol_name = map[int32]string{
	1: "UDP",
	2: "TCP",
}

var SocketProtocol_value = map[string]int32{
	"UDP": 1,
	"TCP": 2,
}

func (x SocketProtocol) Enum() *SocketProtocol {
	p := new(SocketProtocol)
	*p = x
	return p
}

func (x SocketProtocol) String() string {
	return proto.EnumName(SocketProtocol_name, int32(x))
}

func (x *SocketProtocol) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SocketProtocol_value, data, "SocketProtocol")
	if err != nil {
		return err
	}
	*x = SocketProtocol(value)
	return nil
}

func (SocketProtocol) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0f06582ff84ec462, []int{1}
}

// Identifies which field below is filled in.
type Dnstap_Type int32

const (
	Dnstap_MESSAGE Dnstap_Type = 1
)

var Dnstap_Type_name = map[int32]string{
	1: "MESSAGE",
}

var Dnstap_Type_value = map[string]int32{
	"MESSAGE": 1,
}

func (x Dnstap_Type) Enum() *Dnstap_Type {
	p := new(Dnstap_Type)
	*p = x
	return p
}

func (x Dnstap_Type) String() string {
	return proto.EnumName(Dnstap_Type_name, int32(x))
}

func (x *Dnstap_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Dnstap_Type_value, data, "Dnstap_Type")
	if err != nil {
		return err
	}
	*x = Dnstap_Type(value)
	return nil
}

func (Dnstap_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0f06582ff84ec462, []int{0, 0}
}

type Message_Type int32

const (
	// AUTH_QUERY is a DNS query message received from a resolver by an
	// authoritative name server, from the perspective of the authorative
	// name server.
	Message_AUTH_QUERY Message_Type = 1
	// AUTH_RESPONSE is a DNS response message sent from an authoritative
	// name server to a resolver, from the perspective of the authoritative
	// name server.
	Message_AUTH_RESPONSE Message_Type = 2
	// RESOLVER_QUERY is a DNS query message sent from a resolver to an
	// authoritative name server, from the perspective of the resolver.
	// Resolvers typically clear the RD (recursion desired) bit when
	// sending queries.
	Message_RESOLVER_QUERY Message_Type = 3
	// RESOLVER_RESPONSE is a DNS response message received from an
	// authoritative name server by a resolver, from the perspective of
	// the resolver.
	Message_RESOLVER_RESPONSE Message_Type = 4
	// CLIENT_QUERY is a DNS query message sent from a client to a DNS
	// server which is expected to perform further recursion, from the
	// perspective of the DNS server. The client may be a stub resolver or
	// forwarder or some other type of software which typically sets the RD
	// (recursion desired) bit when querying the DNS server. The DNS server
	// may be a simple forwarding proxy or it may be a full recursive
	// resolver.
	Message_CLIENT_QUERY Message_Type = 5
	// CLIENT_RESPONSE is a DNS response message sent from a DNS server to
	// a client, from the perspective of the DNS server. The DNS server
	// typically sets the RA (recursion available) bit when responding.
	Message_CLIENT_RESPONSE Message_Type = 6
	// FORWARDER_QUERY is a DNS query message sent from a downstream DNS
	// server to an upstream DNS server which is expected to perform
	// further recursion, from the perspective of the downstream DNS
	// server.
	Message_FORWARDER_QUERY Message_Type = 7
	// FORWARDER_RESPONSE is a DNS response message sent from an upstream
	// DNS server performing recursion to a downstream DNS server, from the
	// perspective of the downstream DNS server.
	Message_FORWARDER_RESPONSE Message_Type = 8
	// STUB_QUERY is a DNS query message sent from a stub resolver to a DNS
	// server, from the perspective of the stub resolver.
	Message_STUB_QUERY Message_Type = 9
	// STUB_RESPONSE is a DNS response message sent from a DNS server to a
	// stub resolver, from the perspective of the stub resolver.
	Message_STUB_RESPONSE Message_Type = 10
	// TOOL_QUERY is a DNS query message sent from a DNS software tool to a
	// DNS server, from the perspective of the tool.
	Message_TOOL_QUERY Message_Type = 11
	// TOOL_RESPONSE is a DNS response message received by a DNS software
	// tool from a DNS server, from the perspective of the tool.
	Message_TOOL_RESPONSE Message_Type = 12
	// UPDATE_QUERY is a DNS update query message received from a resolver
	// by an authoritative name server, from the perspective of the
	// authoritative name server.
	Message_UPDATE_QUERY Message_Type = 13
	// UPDATE_RESPONSE is a DNS update response message sent from an
	// authoritative name server to a resolver, from the perspective of the
	// authoritative name server.
	Message_UPDATE_RESPONSE Message_Type = 14
)

var Message_Type_name = map[int32]string{
	1:  "AUTH_QUERY",
	2:  "AUTH_RESPONSE",
	3:  "RESOLVER_QUERY",
	4:  "RESOLVER_RESPONSE",
	5:  "CLIENT_QUERY",
	6:  "CLIENT_RESPONSE",
	7:  "FORWARDER_QUERY",
	8:  "FORWARDER_RESPONSE",
	9:  "STUB_QUERY",
	10: "STUB_RESPONSE",
	11: "TOOL_QUERY",
	12: "TOOL_RESPONSE",
	13: "UPDATE_QUERY",
	14: "UPDATE_RESPONSE",
}

var Message_Type_value = map[string]int32{
	"AUTH_QUERY":         1,
	"AUTH_RESPONSE":      2,
	"RESOLVER_QUERY":     3,
	"RESOLVER_RESPONSE":  4,
	"CLIENT_QUERY":       5,
	"CLIENT_RESPONSE":    6,
	"FORWARDER_QUERY":    7,
	"FORWARDER_RESPONSE": 8,
	"STUB_QUERY":         9,
	"STUB_RESPONSE":      10,
	"TOOL_QUERY":         11,
	"TOOL_RESPONSE":      12,
	"UPDATE_QUERY":       13,
	"UPDATE_RESPONSE":    14,
}

func (x Message_Type) Enum() *Message_Type {
	p := new(Message_Type)
	*p = x
	return p
}

func (x Message_Type) String() string {
	return proto.EnumName(Message_Type_name, int32(x))
}

func (x *Message_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Message_Type_value, data, "Message_Type")
	if err != nil {
		return err
	}
	*x = Message_Type(value)
	return nil
}

func (Message_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0f06582ff84ec462, []int{1, 0}
}

// "Dnstap": this is the top-level dnstap type, which is a "union" type that
// contains other kinds of dnstap payloads, although currently only one type
// of dnstap payload is defined.
// See: https://developers.google.com/protocol-buffers/docs/techniques#union
type Dnstap struct {
	// DNS server identity.
	// If enabled, this is the identity string of the DNS server which generated
	// this message. Typically this would be the same string as returned by an
	// "NSID" (RFC 5001) query.
	Identity []byte `protobuf:"bytes,1,opt,name=identity" json:"identity,omitempty"`
	// DNS server version.
	// If enabled, this is the version string of the DNS server which generated
	// this message. Typically this would be the same string as returned by a
	// "version.bind" query.
	Version []byte `protobuf:"bytes,2,opt,name=version" json:"version,omitempty"`
	// Extra data for this payload.
	// This field can be used for adding an arbitrary byte-string annotation to
	// the payload. No encoding or interpretation is applied or enforced.
	Extra []byte       `protobuf:"bytes,3,opt,name=extra" json:"extra,omitempty"`
	Type  *Dnstap_Type `protobuf:"varint,15,req,name=type,enum=dnstap.Dnstap_Type" json:"type,omitempty"`
	// One of the following will be filled in.
	Message              *Message `protobuf:"bytes,14,opt,name=message" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Dnstap) Reset()         { *m = Dnstap{} }
func (m *Dnstap) String() string { return proto.CompactTextString(m) }
func (*Dnstap) ProtoMessage()    {}
func (*Dnstap) Descriptor() ([]byte, []int) {
	return fileDescriptor_0f06582ff84ec462, []int{0}
}

func (m *Dnstap) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Dnstap.Unmarshal(m, b)
}
func (m *Dnstap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Dnstap.Marshal(b, m, deterministic)
}
func (m *Dnstap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Dnstap.Merge(m, src)
}
func (m *Dnstap) XXX_Size() int {
	return xxx_messageInfo_Dnstap.Size(m)
}
func (m *Dnstap) XXX_DiscardUnknown() {
	xxx_messageInfo_Dnstap.DiscardUnknown(m)
}

var xxx_messageInfo_Dnstap proto.InternalMessageInfo

func (m *Dnstap) GetIdentity() []byte {
	if m != nil {
		return m.Identity
	}
	return nil
}

func (m *Dnstap) GetVersion() []byte {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *Dnstap) GetExtra() []byte {
	if m != nil {
		return m.Extra
	}
	return nil
}

func (m *Dnstap) GetType() Dnstap_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Dnstap_MESSAGE
}

func (m *Dnstap) GetMessage() *Message {
	if m != nil {
		return m.Message
	}
	return nil
}

// Message: a wire-format (RFC 1035 section 4) DNS message and associated
// metadata. Applications generating "Message" payloads should follow
// certain requirements based on the MessageType, see below.
type Message struct {
	// One of the Type values described above.
	Type *Message_Type `protobuf:"varint,1,req,name=type,enum=dnstap.Message_Type" json:"type,omitempty"`
	// One of the SocketFamily values described above.
	SocketFamily *SocketFamily `protobuf:"varint,2,opt,name=socket_family,json=socketFamily,enum=dnstap.SocketFamily" json:"socket_family,omitempty"`
	// One of the SocketProtocol values described above.
	SocketProtocol *SocketProtocol `protobuf:"varint,3,opt,name=socket_protocol,json=socketProtocol,enum=dnstap.SocketProtocol" json:"socket_protocol,omitempty"`
	// The network address of the message initiator.
	// For SocketFamily INET, this field is 4 octets (IPv4 address).
	// For SocketFamily INET6, this field is 16 octets (IPv6 address).
	QueryAddress []byte `protobuf:"bytes,4,opt,name=query_address,json=queryAddress" json:"query_address,omitempty"`
	// The network address of the message responder.
	// For SocketFamily INET, this field is 4 octets (IPv4 address).
	// For SocketFamily INET6, this field is 16 octets (IPv6 address).
	ResponseAddress []byte `protobuf:"bytes,5,opt,name=response_address,json=responseAddress" json:"response_address,omitempty"`
	// The transport port of the message initiator.
	// This is a 16-bit UDP or TCP port number, depending on SocketProtocol.
	QueryPort *uint32 `protobuf:"varint,6,opt,name=query_port,json=queryPort" json:"query_port,omitempty"`
	// The transport port of the message responder.
	// This is a 16-bit UDP or TCP port number, depending on SocketProtocol.
	ResponsePort *uint32 `protobuf:"varint,7,opt,name=response_port,json=responsePort" json:"response_port,omitempty"`
	// The time at which the DNS query message was sent or received, depending
	// on whether this is an AUTH_QUERY, RESOLVER_QUERY, or CLIENT_QUERY.
	// This is the number of seconds since the UNIX epoch.
	QueryTimeSec *uint64 `protobuf:"varint,8,opt,name=query_time_sec,json=queryTimeSec" json:"query_time_sec,omitempty"`
	// The time at which the DNS query message was sent or received.
	// This is the seconds fraction, expressed as a count of nanoseconds.
	QueryTimeNsec *uint32 `protobuf:"fixed32,9,opt,name=query_time_nsec,json=queryTimeNsec" json:"query_time_nsec,omitempty"`
	// The initiator's original wire-format DNS query message, verbatim.
	QueryMessage []byte `protobuf:"bytes,10,opt,name=query_message,json=queryMessage" json:"query_message,omitempty"`
	// The "zone" or "bailiwick" pertaining to the DNS query message.
	// This is a wire-format DNS domain name.
	QueryZone []byte `protobuf:"bytes,11,opt,name=query_zone,json=queryZone" json:"query_zone,omitempty"`
	// The time at which the DNS response message was sent or received,
	// depending on whether this is an AUTH_RESPONSE, RESOLVER_RESPONSE, or
	// CLIENT_RESPONSE.
	// This is the number of seconds since the UNIX epoch.
	ResponseTimeSec *uint64 `protobuf:"varint,12,opt,name=response_time_sec,json=responseTimeSec" json:"response_time_sec,omitempty"`
	// The time at which the DNS response message was sent or received.
	// This is the seconds fraction, expressed as a count of nanoseconds.
	ResponseTimeNsec *uint32 `protobuf:"fixed32,13,opt,name=response_time_nsec,json=responseTimeNsec" json:"response_time_nsec,omitempty"`
	// The responder's original wire-format DNS response message, verbatim.
	ResponseMessage []byte `protobuf:"bytes,14,opt,name=response_message,json=responseMessage" json:"response_message,omitempty"`
	// Start of Infoblox specific log messages
	SubscriberId         []byte   `protobuf:"bytes,15,opt,name=subscriber_id,json=subscriberId" json:"subscriber_id,omitempty"`
	LocalId              *uint64  `protobuf:"varint,16,opt,name=local_id,json=localId" json:"local_id,omitempty"`
	PcpSsp               []byte   `protobuf:"bytes,17,opt,name=pcp_ssp,json=pcpSsp" json:"pcp_ssp,omitempty"`
	ProxyAll             []byte   `protobuf:"bytes,18,opt,name=proxy_all,json=proxyAll" json:"proxy_all,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Message) Reset()         { *m = Message{} }
func (m *Message) String() string { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()    {}
func (*Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_0f06582ff84ec462, []int{1}
}

func (m *Message) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Message.Unmarshal(m, b)
}
func (m *Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Message.Marshal(b, m, deterministic)
}
func (m *Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message.Merge(m, src)
}
func (m *Message) XXX_Size() int {
	return xxx_messageInfo_Message.Size(m)
}
func (m *Message) XXX_DiscardUnknown() {
	xxx_messageInfo_Message.DiscardUnknown(m)
}

var xxx_messageInfo_Message proto.InternalMessageInfo

func (m *Message) GetType() Message_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Message_AUTH_QUERY
}

func (m *Message) GetSocketFamily() SocketFamily {
	if m != nil && m.SocketFamily != nil {
		return *m.SocketFamily
	}
	return SocketFamily_INET
}

func (m *Message) GetSocketProtocol() SocketProtocol {
	if m != nil && m.SocketProtocol != nil {
		return *m.SocketProtocol
	}
	return SocketProtocol_UDP
}

func (m *Message) GetQueryAddress() []byte {
	if m != nil {
		return m.QueryAddress
	}
	return nil
}

func (m *Message) GetResponseAddress() []byte {
	if m != nil {
		return m.ResponseAddress
	}
	return nil
}

func (m *Message) GetQueryPort() uint32 {
	if m != nil && m.QueryPort != nil {
		return *m.QueryPort
	}
	return 0
}

func (m *Message) GetResponsePort() uint32 {
	if m != nil && m.ResponsePort != nil {
		return *m.ResponsePort
	}
	return 0
}

func (m *Message) GetQueryTimeSec() uint64 {
	if m != nil && m.QueryTimeSec != nil {
		return *m.QueryTimeSec
	}
	return 0
}

func (m *Message) GetQueryTimeNsec() uint32 {
	if m != nil && m.QueryTimeNsec != nil {
		return *m.QueryTimeNsec
	}
	return 0
}

func (m *Message) GetQueryMessage() []byte {
	if m != nil {
		return m.QueryMessage
	}
	return nil
}

func (m *Message) GetQueryZone() []byte {
	if m != nil {
		return m.QueryZone
	}
	return nil
}

func (m *Message) GetResponseTimeSec() uint64 {
	if m != nil && m.ResponseTimeSec != nil {
		return *m.ResponseTimeSec
	}
	return 0
}

func (m *Message) GetResponseTimeNsec() uint32 {
	if m != nil && m.ResponseTimeNsec != nil {
		return *m.ResponseTimeNsec
	}
	return 0
}

func (m *Message) GetResponseMessage() []byte {
	if m != nil {
		return m.ResponseMessage
	}
	return nil
}

func (m *Message) GetSubscriberId() []byte {
	if m != nil {
		return m.SubscriberId
	}
	return nil
}

func (m *Message) GetLocalId() uint64 {
	if m != nil && m.LocalId != nil {
		return *m.LocalId
	}
	return 0
}

func (m *Message) GetPcpSsp() []byte {
	if m != nil {
		return m.PcpSsp
	}
	return nil
}

func (m *Message) GetProxyAll() []byte {
	if m != nil {
		return m.ProxyAll
	}
	return nil
}

func init() {
	proto.RegisterEnum("dnstap.SocketFamily", SocketFamily_name, SocketFamily_value)
	proto.RegisterEnum("dnstap.SocketProtocol", SocketProtocol_name, SocketProtocol_value)
	proto.RegisterEnum("dnstap.Dnstap_Type", Dnstap_Type_name, Dnstap_Type_value)
	proto.RegisterEnum("dnstap.Message_Type", Message_Type_name, Message_Type_value)
	proto.RegisterType((*Dnstap)(nil), "dnstap.Dnstap")
	proto.RegisterType((*Message)(nil), "dnstap.Message")
}

func init() { proto.RegisterFile("dnstap.proto", fileDescriptor_0f06582ff84ec462) }

var fileDescriptor_0f06582ff84ec462 = []byte{
	// 665 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x5c, 0x93, 0xd1, 0x6e, 0xd3, 0x4a,
	0x10, 0x86, 0xe5, 0x34, 0x89, 0x93, 0x89, 0xed, 0x38, 0xd3, 0x9e, 0x1e, 0x9f, 0x83, 0x90, 0xa2,
	0x14, 0x41, 0x5a, 0xa1, 0x5e, 0xf4, 0x02, 0x89, 0x2b, 0x14, 0x1a, 0x17, 0x22, 0xb5, 0x49, 0xb0,
	0x1d, 0x10, 0xdc, 0x44, 0xa9, 0xbd, 0x20, 0x0b, 0xc7, 0x36, 0x5e, 0x17, 0x35, 0xbc, 0x07, 0x8f,
	0xc3, 0xfb, 0xf0, 0x18, 0xc8, 0xe3, 0xf5, 0xd6, 0xe1, 0x6e, 0xff, 0x7f, 0xbe, 0xdd, 0xf9, 0x77,
	0xec, 0x05, 0x2d, 0x88, 0x79, 0xbe, 0x49, 0xcf, 0xd3, 0x2c, 0xc9, 0x13, 0x6c, 0x97, 0x6a, 0xf4,
	0x4b, 0x81, 0xf6, 0x94, 0x96, 0xf8, 0x3f, 0x74, 0xc2, 0x80, 0xc5, 0x79, 0x98, 0xef, 0x2c, 0x65,
	0xa8, 0x8c, 0x35, 0x47, 0x6a, 0xb4, 0x40, 0xfd, 0xce, 0x32, 0x1e, 0x26, 0xb1, 0xd5, 0xa0, 0x52,
	0x25, 0xf1, 0x08, 0x5a, 0xec, 0x3e, 0xcf, 0x36, 0xd6, 0x01, 0xf9, 0xa5, 0xc0, 0x67, 0xd0, 0xcc,
	0x77, 0x29, 0xb3, 0xfa, 0xc3, 0xc6, 0xd8, 0xb8, 0x38, 0x3c, 0x17, 0xbd, 0xcb, 0x4e, 0xe7, 0xde,
	0x2e, 0x65, 0x0e, 0x01, 0x78, 0x0a, 0xea, 0x96, 0x71, 0xbe, 0xf9, 0xc2, 0x2c, 0x63, 0xa8, 0x8c,
	0x7b, 0x17, 0xfd, 0x8a, 0xbd, 0x29, 0x6d, 0xa7, 0xaa, 0x8f, 0x0e, 0xa1, 0x59, 0x6c, 0xc4, 0x1e,
	0xa8, 0x37, 0xb6, 0xeb, 0x4e, 0xde, 0xd8, 0xa6, 0x32, 0xfa, 0xad, 0x82, 0x2a, 0x48, 0x1c, 0x8b,
	0xa6, 0x0a, 0x35, 0x3d, 0xfa, 0xeb, 0xa0, 0x7a, 0xd7, 0x97, 0xa0, 0xf3, 0xc4, 0xff, 0xca, 0xf2,
	0xf5, 0xe7, 0xcd, 0x36, 0x8c, 0x76, 0x74, 0xa9, 0xda, 0x16, 0x97, 0x8a, 0x57, 0x54, 0x73, 0x34,
	0x5e, 0x53, 0xf8, 0x0a, 0xfa, 0x62, 0x2b, 0x0d, 0xd2, 0x4f, 0x22, 0xba, 0xb9, 0x71, 0x71, 0xbc,
	0xbf, 0x79, 0x29, 0xaa, 0x8e, 0xc1, 0xf7, 0x34, 0x9e, 0x80, 0xfe, 0xed, 0x8e, 0x65, 0xbb, 0xf5,
	0x26, 0x08, 0x32, 0xc6, 0xb9, 0xd5, 0xa4, 0xc1, 0x69, 0x64, 0x4e, 0x4a, 0x0f, 0x4f, 0xc1, 0xcc,
	0x18, 0x4f, 0x93, 0x98, 0x33, 0xc9, 0xb5, 0x88, 0xeb, 0x57, 0x7e, 0x85, 0x3e, 0x06, 0x28, 0xcf,
	0x4b, 0x93, 0x2c, 0xb7, 0xda, 0x43, 0x65, 0xac, 0x3b, 0x5d, 0x72, 0x96, 0x49, 0x96, 0x17, 0xed,
	0xe4, 0x49, 0x44, 0xa8, 0x44, 0x68, 0x95, 0x49, 0xd0, 0x13, 0x30, 0xca, 0x33, 0xf2, 0x70, 0xcb,
	0xd6, 0x9c, 0xf9, 0x56, 0x67, 0xa8, 0x8c, 0x9b, 0x22, 0x94, 0x17, 0x6e, 0x99, 0xcb, 0x7c, 0x7c,
	0x0a, 0xfd, 0x1a, 0x15, 0x17, 0x58, 0x77, 0xa8, 0x8c, 0x55, 0x47, 0x97, 0xd8, 0x9c, 0x33, 0xff,
	0xe1, 0x86, 0xd5, 0x97, 0x85, 0xda, 0x0d, 0xab, 0x8f, 0x25, 0x63, 0xff, 0x48, 0x62, 0x66, 0xf5,
	0x88, 0x28, 0x63, 0x7f, 0x4a, 0x62, 0x86, 0x67, 0x30, 0x90, 0xb1, 0x65, 0x28, 0x8d, 0x42, 0xc9,
	0x09, 0x54, 0xb9, 0x9e, 0x03, 0xee, 0xb3, 0x14, 0x4d, 0xa7, 0x68, 0x66, 0x1d, 0xa6, 0x74, 0xf5,
	0xd1, 0xd6, 0x7f, 0xbd, 0xda, 0x68, 0xab, 0x8c, 0x27, 0xa0, 0xf3, 0xbb, 0x5b, 0xee, 0x67, 0xe1,
	0x2d, 0xcb, 0xd6, 0x61, 0x60, 0xf5, 0xcb, 0x8b, 0x3c, 0x98, 0xb3, 0x00, 0xff, 0x83, 0x4e, 0x94,
	0xf8, 0x9b, 0xa8, 0xa8, 0x9b, 0x14, 0x50, 0x25, 0x3d, 0x0b, 0xf0, 0x5f, 0x50, 0x53, 0x3f, 0x5d,
	0x73, 0x9e, 0x5a, 0x03, 0xda, 0xd9, 0x4e, 0xfd, 0xd4, 0xe5, 0x29, 0x3e, 0x82, 0x6e, 0x9a, 0x25,
	0xf7, 0xbb, 0xf5, 0x26, 0x8a, 0x2c, 0x2c, 0xdf, 0x1a, 0x19, 0x93, 0x28, 0x1a, 0xfd, 0x6c, 0x88,
	0x1f, 0xdd, 0x00, 0x98, 0xac, 0xbc, 0xb7, 0xeb, 0x77, 0x2b, 0xdb, 0xf9, 0x68, 0x2a, 0x38, 0x00,
	0x9d, 0xb4, 0x63, 0xbb, 0xcb, 0xc5, 0xdc, 0xb5, 0xcd, 0x06, 0x22, 0x18, 0x8e, 0xed, 0x2e, 0xae,
	0xdf, 0xdb, 0x8e, 0xc0, 0x0e, 0xf0, 0x1f, 0x18, 0x48, 0x4f, 0xa2, 0x4d, 0x34, 0x41, 0xbb, 0xbc,
	0x9e, 0xd9, 0x73, 0x4f, 0x80, 0x2d, 0x3c, 0x84, 0xbe, 0x70, 0x24, 0xd6, 0x2e, 0xcc, 0xab, 0x85,
	0xf3, 0x61, 0xe2, 0x4c, 0xe5, 0x91, 0x2a, 0x1e, 0x03, 0x3e, 0x98, 0x12, 0xee, 0x14, 0x09, 0x5d,
	0x6f, 0xf5, 0x5a, 0x70, 0xdd, 0x22, 0x21, 0x69, 0x89, 0x40, 0x81, 0x78, 0x8b, 0xc5, 0xb5, 0x40,
	0x7a, 0x05, 0x42, 0x5a, 0x22, 0x5a, 0x91, 0x6c, 0xb5, 0x9c, 0x4e, 0x3c, 0x5b, 0x40, 0x7a, 0x11,
	0x42, 0x38, 0x12, 0x33, 0xce, 0x4e, 0x40, 0xab, 0xbf, 0x4b, 0xec, 0x40, 0x73, 0x36, 0xb7, 0x3d,
	0x53, 0xc1, 0x2e, 0xb4, 0x8a, 0xd5, 0x0b, 0xb3, 0x71, 0x36, 0x02, 0x63, 0xff, 0xfd, 0xa1, 0x0a,
	0x07, 0xab, 0xe9, 0xd2, 0x54, 0x8a, 0x85, 0x77, 0xb9, 0x34, 0x1b, 0x7f, 0x02, 0x00, 0x00, 0xff,
	0xff, 0x55, 0xe7, 0xb7, 0x49, 0x0a, 0x05, 0x00, 0x00,
}
